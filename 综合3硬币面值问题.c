/*【问题描述】

蚂蚁王国在不断进化中，不但创建了它们自己的政府，而且选择了建立了自己的货币系统。它们对货币系统感到好奇。

传统地，一个货币系统是由1,5,10,20 或 25,50, 和 100的单位面值组成的。

蚂蚁想知道有多少种不同的方法来用货币系统中的货币来构造一个确定的数值。

举例来说, 使用一个货币系统 {1,2,5,10,...}产生 18单位面值的一些可能的方法是:18x1, 9x2, 8x2+2x1, 3x5+2+1,等等其它。

写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。保证总数在0 到2^63-1之间。



【输入形式】

货币系统中货币的种类数目是 V (1<=V<=25)。要构造的数量钱是 N (1<= N<=10,000)。

第一行: 二个整数，V 和 N 。

第二行： 可用的货币的面值 ，以空格作为分隔符。

【输出形式】

单独 的一行包含那个可能的用这v种硬币凑足n单位货币的方案数R。



【样例输入】

3 10

1 2 5
 【样例输出】

10
*/ 

#include<stdio.h>
/*At first，我使用了递归的方法，f(n,x)=f(n-1,x)+f(n-1,x-1*value[n])+.......+f(n-1,x-k*value[n])
    注意，如果将x-1*value[n]带x，则原递推式又可以简化成f(n,x)=f(n-1,x)+f(n,x-value[n])   （这样又少了一层循环）
    但是由于数值过大运行时间过长，所以不能这样
    后来，采取了n*x的二维数组的方法，记录用前n种面值凑出x元的方法数，解决了时间复杂度
    后来，发现递推式里是二项递推，n只和n-1相关，那么不用开那么多的数组，只用basic和solution两个1维数组，存储前n-1
    种硬币凑出x的方法数和前n种硬币凑出x的方法数，通过basic求出solution后，可以把basic=solution，进而求n+1时的solution
    具体代码如下：

*/

int main(){
    int n,x,i,j,basic[10001]={0},solution[10001]={0},value[26];
    scanf("%d %d",&n,&x);
    for(i=1;i<=n;i++)   //把硬币面额记录在value【1――n】里
        scanf("%d",&value[i]);
    j=0;i=0;
    while(j<=x){
        basic[j]=solution[j]=1;
        j=j+value[1];
    }           //初始化用第一种面值生成对应j元钱的方法为一种，其余均为0
    for(i=2;i<=n;i++){  //从前两种 循环到 前n种，循环结束
        for(j=0;j<=x;j++)
            if((j-value[i])>=0) solution[j]=basic[j]+solution[j-value[i]];//核心递推式 。solution(j)表示用当前的前i种硬币组成j元钱的方法数
        for(j=0;j<=x;j++)
            basic[j]=solution[j];   //迭代 进而计算下一次前i+1种硬币时的solution
    }
    printf("%d",solution[x]);   //f(n,x)
return 0;
}
